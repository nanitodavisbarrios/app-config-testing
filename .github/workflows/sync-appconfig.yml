name: Sync Azure App Configuration (build once, deploy many)

on:
  workflow_dispatch:
    inputs:
      runDev:
        description: "Build+Deploy DEV?"
        required: true
        default: "true"
      runTest:
        description: "Build+Deploy TEST?"
        required: true
        default: "false"
      runProd:
        description: "Build+Deploy PROD?"
        required: true
        default: "false"

permissions:
  contents: read

env:
  # Fallback BU if not set at Environment level (optional)
  DEFAULT_BU: canada

jobs:
  # =========================================================================================
  # BUILD the resolved features file(s) from templates + variables and upload as artifacts
  # =========================================================================================
  build_files:
    name: Build features ops file(s)
    runs-on: windows-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Build DEV ops file
        if: ${{ inputs.runDev == 'true' }}
        shell: pwsh
        env:
          BU: ${{ vars.BU != '' && vars.BU || env.DEFAULT_BU }}
          FEATURES_PATH: config/${{ vars.BU != '' && vars.BU || env.DEFAULT_BU }}/features.json
          VARS_PATH:     config/${{ vars.BU != '' && vars.BU || env.DEFAULT_BU }}/variables.dev.json
          OUT_PATH:      ${{ runner.temp }}\features-dev.ops.json
        run: |
          $ErrorActionPreference='Stop'
          az config set extension.use_dynamic_install=yes_without_prompt | Out-Null

          # ---- helpers (same as before, trimmed to what's needed) ----
          function Read-Json([string]$Path) {
            $full = Join-Path $env:GITHUB_WORKSPACE $Path
            if (-not (Test-Path -LiteralPath $full)) { throw "File not found: $full" }
            $txt = Get-Content -LiteralPath $full -Raw -Encoding utf8
            $txt = [regex]::Replace($txt,'(?m)^\s*//.*$','')
            $txt = [regex]::Replace($txt,'(?s)/\*.*?\*/','')
            $txt = [regex]::Replace($txt,',\s*(\})','$1')
            $txt = [regex]::Replace($txt,',\s*(\])','$1')
            return $txt | ConvertFrom-Json -Depth 200
          }
          function To-HT($o) {
            if ($null -eq $o) { return @{} }
            if ($o -is [pscustomobject]) { $h=@{}; $o.PSObject.Properties|%{$h[$_.Name]=To-HT $_.Value}; return $h }
            elseif ($o -is [System.Collections.IDictionary]) { $h=@{}; foreach($k in $o.Keys){$h[$k]=To-HT $o[$k]}; return $h }
            elseif ($o -is [System.Collections.IList]) { $a=@(); foreach($v in $o){$a+=,(To-HT $v)}; return $a }
            else { return $o }
          }
          function Resolve-Template($node,$ctx){
            if ($node -is [string]) {
              $m=[regex]::Match($node,'^\$\{([A-Z0-9_]+)\}$'); if($m.Success){return $ctx[$m.Groups[1].Value]}
              return [regex]::Replace($node,'\$\{([A-Z0-9_]+)\}',{param($m)[string]$ctx[$m.Groups[1].Value]})
            } elseif ($node -is [pscustomobject] -or $node -is [System.Collections.IDictionary]) {
              $h=@{}; $names= if($node -is [pscustomobject]){$node.PSObject.Properties.Name}else{$node.Keys}
              foreach($k in $names){ $h[$k]=Resolve-Template $node.$k $ctx }; return $h
            } elseif ($node -is [System.Collections.IList]) {
              $arr=@(); foreach($v in $node){$arr+=,(Resolve-Template $v $ctx)}; return $arr
            } else { return $node }
          }

          # ---- load ----
          $features = Read-Json $env:FEATURES_PATH
          $varsObj  = Read-Json $env:VARS_PATH
          $ctx      = To-HT $varsObj

          # env overrides (none expected here, but harmless)
          Get-ChildItem Env: | %{
            $k=$_.Name; $v=$_.Value
            if ($ctx.ContainsKey($k) -and ($ctx[$k] -is [bool])) { $ctx[$k]=($v -match '^(?i:true|1)$') } else { $ctx[$k]=$v }
          }

          # default label from vars; per-feature can override later
          $defaultLabel = $ctx['TARGET_LABEL']

          # build ops array (resolved values; avoid quoting issues at deploy time)
          $ops = @()
          foreach($f in $features.features){
            $key  = $f.key
            $type = if($f.type){$f.type}else{'json'}

            # per-feature label (inherit default)
            $featureLabel = $defaultLabel
            if ($f | Get-Member -Name label -MemberType NoteProperty) {
              $raw = $f.label
              $featureLabel = ($raw -is [string]) ? (Resolve-Template $raw $ctx) : $raw
            }

            switch($type){
              'json' {
                $rendered = Resolve-Template $f.template $ctx
                $jsonVal  = $rendered | ConvertTo-Json -Depth 200 -Compress
                $ops += [pscustomobject]@{
                  type='json'; key=$key; label=$featureLabel; contentType='application/json'; value=$jsonVal
                }
              }
              'string' {
                $rendered = Resolve-Template $f.value $ctx
                $str = ($rendered -is [string]) ? $rendered : ($rendered|ConvertTo-Json -Compress -Depth 8)
                $ops += [pscustomobject]@{
                  type='string'; key=$key; label=$featureLabel; contentType='text/plain'; value=$str
                }
              }
              'kvref' {
                $varName = $f.secretVar
                $val = $ctx[$varName]
                if (-not $val) { Write-Host ("Skip {0}: {1} not set" -f $key, $varName); continue }
                $secretId = ($val -like 'https://*') ? $val : ("https://{0}.vault.azure.net/secrets/{1}" -f $ctx['KEYVAULT_NAME'],$val)
                $ops += [pscustomobject]@{
                  type='kvref'; key=$key; label=$featureLabel; secretId=$secretId
                }
              }
              default { Write-Host ("Unknown type '{0}' for {1}; skipping." -f $type,$key) }
            }
          }

          $manifest = [pscustomobject]@{
            generatedAt = (Get-Date).ToUniversalTime().ToString('s')+'Z'
            environment = 'dev'
            bu          = $env:BU
            defaultLabel= $defaultLabel
            ops         = $ops
          } | ConvertTo-Json -Depth 300

          New-Item -ItemType Directory -Force -Path (Split-Path -Parent $env:OUT_PATH) | Out-Null
          Set-Content -LiteralPath $env:OUT_PATH -Value $manifest -Encoding utf8 -NoNewline
          Write-Host "Built DEV ops -> $env:OUT_PATH"

      - name: Upload DEV artifact
        if: ${{ inputs.runDev == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: features-dev
          path: ${{ runner.temp }}\features-dev.ops.json

      - name: Build TEST ops file
        if: ${{ inputs.runTest == 'true' }}
        shell: pwsh
        env:
          BU: ${{ vars.BU != '' && vars.BU || env.DEFAULT_BU }}
          FEATURES_PATH: config/${{ vars.BU != '' && vars.BU || env.DEFAULT_BU }}/features.json
          VARS_PATH:     config/${{ vars.BU != '' && vars.BU || env.DEFAULT_BU }}/variables.test.json
          OUT_PATH:      ${{ runner.temp }}\features-test.ops.json
        run: |
          # same block as DEV above, but set environment='test' before writing file
          $ErrorActionPreference='Stop'
          az config set extension.use_dynamic_install=yes_without_prompt | Out-Null
          function Read-Json([string]$Path){$full=Join-Path $env:GITHUB_WORKSPACE $Path;if(-not(Test-Path $full)){throw "File not found: $full"};$t=Get-Content -LiteralPath $full -Raw -Encoding utf8;$t=[regex]::Replace($t,'(?m)^\s*//.*$','');$t=[regex]::Replace($t,'(?s)/\*.*?\*/','');$t=[regex]::Replace($t,',\s*(\})','$1');$t=[regex]::Replace($t,',\s*(\])','$1');$t|ConvertFrom-Json -Depth 200}
          function To-HT($o){if($null -eq $o){return @{}}elseif($o -is [pscustomobject]){$h=@{};$o.PSObject.Properties|%{$h[$_.Name]=To-HT $_.Value};return $h}elseif($o -is [System.Collections.IDictionary]){$h=@{};foreach($k in $o.Keys){$h[$k]=To-HT $o[$k]};return $h}elseif($o -is [System.Collections.IList]){$a=@();foreach($v in $o){$a+=,(To-HT $v)};return $a}else{return $o}}
          function Resolve-Template($n,$c){if($n -is [string]){$m=[regex]::Match($n,'^\$\{([A-Z0-9_]+)\}$');if($m.Success){return $c[$m.Groups[1].Value]}return [regex]::Replace($n,'\$\{([A-Z0-9_]+)\}',{param($m)[string]$c[$m.Groups[1].Value]})}elseif($n -is [pscustomobject] -or $n -is [System.Collections.IDictionary]){$h=@{};$names=if($n -is [pscustomobject]){$n.PSObject.Properties.Name}else{$n.Keys};foreach($k in $names){$h[$k]=Resolve-Template $n.$k $c};return $h}elseif($n -is [System.Collections.IList]){$arr=@();foreach($v in $n){$arr+=,(Resolve-Template $v $c)};return $arr}else{return $n}}
          $features=Read-Json $env:FEATURES_PATH; $varsObj=Read-Json $env:VARS_PATH; $ctx=To-HT $varsObj
          $defaultLabel=$ctx['TARGET_LABEL']; Get-ChildItem Env:|%{$k=$_.Name;$v=$_.Value;if($ctx.ContainsKey($k)-and($ctx[$k]-is[bool])){$ctx[$k]=($v -match '^(?i:true|1)$')}else{$ctx[$k]=$v}}
          $ops=@(); foreach($f in $features.features){$key=$f.key;$type=if($f.type){$f.type}else{'json'};$featureLabel=$defaultLabel;if($f|Get-Member -Name label -MemberType NoteProperty){$raw=$f.label;$featureLabel=($raw -is [string])?(Resolve-Template $raw $ctx):$raw}
            switch($type){
              'json'   {$rendered=Resolve-Template $f.template $ctx;$jsonVal=$rendered|ConvertTo-Json -Depth 200 -Compress;$ops+=@{type='json';key=$key;label=$featureLabel;contentType='application/json';value=$jsonVal}}
              'string' {$rendered=Resolve-Template $f.value $ctx;$str=($rendered -is [string])?$rendered:($rendered|ConvertTo-Json -Compress -Depth 8);$ops+=@{type='string';key=$key;label=$featureLabel;contentType='text/plain';value=$str}}
              'kvref'  {$varName=$f.secretVar;$val=$ctx[$varName]; if(-not $val){Write-Host ("Skip {0}: {1} not set" -f $key,$varName);continue}; $secretId=($val -like 'https://*')?$val:("https://{0}.vault.azure.net/secrets/{1}" -f $ctx['KEYVAULT_NAME'],$val); $ops+=@{type='kvref';key=$key;label=$featureLabel;secretId=$secretId}}
              default  {Write-Host ("Unknown type '{0}' for {1}; skipping." -f $type,$key)}
            }}
          $manifest=[pscustomobject]@{generatedAt=(Get-Date).ToUniversalTime().ToString('s')+'Z';environment='test';bu=$env:BU;defaultLabel=$defaultLabel;ops=$ops}|ConvertTo-Json -Depth 300
          Set-Content -LiteralPath $env:OUT_PATH -Value $manifest -Encoding utf8 -NoNewline
          Write-Host "Built TEST ops -> $env:OUT_PATH"

      - name: Upload TEST artifact
        if: ${{ inputs.runTest == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: features-test
          path: ${{ runner.temp }}\features-test.ops.json

      - name: Build PROD ops file
        if: ${{ inputs.runProd == 'true' }}
        shell: pwsh
        env:
          BU: ${{ vars.BU != '' && vars.BU || env.DEFAULT_BU }}
          FEATURES_PATH: config/${{ vars.BU != '' && vars.BU || env.DEFAULT_BU }}/features.json
          VARS_PATH:     config/${{ vars.BU != '' && vars.BU || env.DEFAULT_BU }}/variables.prod.json
          OUT_PATH:      ${{ runner.temp }}\features-prod.ops.json
        run: |
          # identical to TEST block, but environment='prod' and OUT_PATH uses prod
          $ErrorActionPreference='Stop'
          az config set extension.use_dynamic_install=yes_without_prompt | Out-Null
          function Read-Json([string]$Path){$full=Join-Path $env:GITHUB_WORKSPACE $Path;if(-not(Test-Path $full)){throw "File not found: $full"};$t=Get-Content -LiteralPath $full -Raw -Encoding utf8;$t=[regex]::Replace($t,'(?m)^\s*//.*$','');$t=[regex]::Replace($t,'(?s)/\*.*?\*/','');$t=[regex]::Replace($t,',\s*(\})','$1');$t=[regex]::Replace($t,',\s*(\])','$1');$t|ConvertFrom-Json -Depth 200}
          function To-HT($o){if($null -eq $o){return @{}}elseif($o -is [pscustomobject]){$h=@{};$o.PSObject.Properties|%{$h[$_.Name]=To-HT $_.Value};return $h}elseif($o -is [System.Collections.IDictionary]){$h=@{};foreach($k in $o.Keys){$h[$k]=To-HT $o[$k]};return $h}elseif($o -is [System.Collections.IList]){$a=@();foreach($v in $o){$a+=,(To-HT $v)};return $a}else{return $o}}
          function Resolve-Template($n,$c){if($n -is [string]){$m=[regex]::Match($n,'^\$\{([A-Z0-9_]+)\}$');if($m.Success){return $c[$m.Groups[1].Value]}return [regex]::Replace($n,'\$\{([A-Z0-9_]+)\}',{param($m)[string]$c[$m.Groups[1].Value]})}elseif($n -is [pscustomobject] -or $n -is [System.Collections.IDictionary]){$h=@{};$names=if($n -is [pscustomobject]){$n.PSObject.Properties.Name}else{$n.Keys};foreach($k in $names){$h[$k]=Resolve-Template $n.$k $c};return $h}elseif($n -is [System.Collections.IList]){$arr=@();foreach($v in $n){$arr+=,(Resolve-Template $v $c)};return $arr}else{return $n}}
          $features=Read-Json $env:FEATURES_PATH; $varsObj=Read-Json $env:VARS_PATH; $ctx=To-HT $varsObj
          $defaultLabel=$ctx['TARGET_LABEL']; Get-ChildItem Env:|%{$k=$_.Name;$v=$_.Value;if($ctx.ContainsKey($k)-and($ctx[$k]-is[bool])){$ctx[$k]=($v -match '^(?i:true|1)$')}else{$ctx[$k]=$v}}
          $ops=@(); foreach($f in $features.features){$key=$f.key;$type=if($f.type){$f.type}else{'json'};$featureLabel=$defaultLabel;if($f|Get-Member -Name label -MemberType NoteProperty){$raw=$f.label;$featureLabel=($raw -is [string])?(Resolve-Template $raw $ctx):$raw}
            switch($type){
              'json'   {$rendered=Resolve-Template $f.template $ctx;$jsonVal=$rendered|ConvertTo-Json -Depth 200 -Compress;$ops+=@{type='json';key=$key;label=$featureLabel;contentType='application/json';value=$jsonVal}}
              'string' {$rendered=Resolve-Template $f.value $ctx;$str=($rendered -is [string])?$rendered:($rendered|ConvertTo-Json -Compress -Depth 8);$ops+=@{type='string';key=$key;label=$featureLabel;contentType='text/plain';value=$str}}
              'kvref'  {$varName=$f.secretVar;$val=$ctx[$varName]; if(-not $val){Write-Host ("Skip {0}: {1} not set" -f $key,$varName);continue}; $secretId=($val -like 'https://*')?$val:("https://{0}.vault.azure.net/secrets/{1}" -f $ctx['KEYVAULT_NAME'],$val); $ops+=@{type='kvref';key=$key;label=$featureLabel;secretId=$secretId}}
              default  {Write-Host ("Unknown type '{0}' for {1}; skipping." -f $type,$key)}
            }}
          $manifest=[pscustomobject]@{generatedAt=(Get-Date).ToUniversalTime().ToString('s')+'Z';environment='prod';bu=$env:BU;defaultLabel=$defaultLabel;ops=$ops}|ConvertTo-Json -Depth 300
          Set-Content -LiteralPath $env:OUT_PATH -Value $manifest -Encoding utf8 -NoNewline
          Write-Host "Built PROD ops -> $env:OUT_PATH"

      - name: Upload PROD artifact
        if: ${{ inputs.runProd == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: features-prod
          path: ${{ runner.temp }}\features-prod.ops.json

  # =========================================================================================
  # DEPLOY JOBS — download the built artifact and push to App Config
  # (Approvals happen automatically via Environment protection rules)
  # =========================================================================================

  deploy_dev:
    if: ${{ inputs.runDev == 'true' }}
    name: Deploy to DEV
    runs-on: windows-latest
    needs: build_files
    environment: dev
    steps:
      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: features-dev
          path: ./artifact

      - name: Push ops to App Config (DEV)
        shell: pwsh
        env:
          APPCONFIG_CONNECTION_STRING: ${{ secrets.APPCONFIG_CONNECTION_STRING }}
        run: |
          $ErrorActionPreference='Stop'
          az config set extension.use_dynamic_install=yes_without_prompt | Out-Null
          $file = Get-ChildItem -LiteralPath ./artifact -Filter *.json | Select-Object -First 1
          if (-not $file) { throw "No ops file found in artifact." }
          $doc = Get-Content -LiteralPath $file.FullName -Raw | ConvertFrom-Json -Depth 200
          $acArgs = @('--connection-string', "${env:APPCONFIG_CONNECTION_STRING}")

          foreach($op in $doc.ops){
            $labelArgs = @(); if ($op.label -and $op.label -ne '_NO_LABEL_') { $labelArgs=@('--label', $op.label) }
            switch($op.type){
              'json'   {
                $tmp=New-TemporaryFile; Set-Content -LiteralPath $tmp -Value $op.value -Encoding utf8 -NoNewline
                az appconfig kv set @acArgs --key $op.key @labelArgs --value "@$tmp" --content-type $op.contentType --yes
                Remove-Item $tmp -Force -ErrorAction SilentlyContinue
              }
              'string' {
                $tmp=New-TemporaryFile; Set-Content -LiteralPath $tmp -Value $op.value -Encoding utf8 -NoNewline
                az appconfig kv set @acArgs --key $op.key @labelArgs --value "@$tmp" --content-type $op.contentType --yes
                Remove-Item $tmp -Force -ErrorAction SilentlyContinue
              }
              'kvref'  {
                az appconfig kv set-keyvault @acArgs --key $op.key @labelArgs --secret-identifier $op.secretId --yes
              }
              default  { Write-Host ("Unknown op type '{0}' for key {1}" -f $op.type,$op.key) }
            }
          }
          az appconfig kv list @acArgs --key "Feature:*" -o table

  deploy_test:
    if: ${{ inputs.runTest == 'true' }}
    name: Deploy to TEST
    runs-on: windows-latest
    needs: build_files
    environment: CANADA-TST   # <-- add Required reviewers in Settings → Environments
    steps:
      - uses: actions/download-artifact@v4
        with:
          name: features-test
          path: ./artifact
      - name: Push ops to App Config (TEST)
        shell: pwsh
        env:
          APPCONFIG_CONNECTION_STRING: ${{ secrets.APPCONFIG_CONNECTION_STRING }}
        run: |
          $ErrorActionPreference='Stop'
          az config set extension.use_dynamic_install=yes_without_prompt | Out-Null
          $file = Get-ChildItem -LiteralPath ./artifact -Filter *.json | Select-Object -First 1
          if (-not $file) { throw "No ops file found in artifact." }
          $doc = Get-Content -LiteralPath $file.FullName -Raw | ConvertFrom-Json -Depth 200
          $acArgs = @('--connection-string', "${env:APPCONFIG_CONNECTION_STRING}")
          foreach($op in $doc.ops){
            $labelArgs = @(); if ($op.label -and $op.label -ne '_NO_LABEL_') { $labelArgs=@('--label', $op.label) }
            switch($op.type){
              'json'   {$t=New-TemporaryFile;Set-Content -LiteralPath $t -Value $op.value -Encoding utf8 -NoNewline; az appconfig kv set @acArgs --key $op.key @labelArgs --value "@$t" --content-type $op.contentType --yes; Remove-Item $t -Force -ErrorAction SilentlyContinue}
              'string' {$t=New-TemporaryFile;Set-Content -LiteralPath $t -Value $op.value -Encoding utf8 -NoNewline; az appconfig kv set @acArgs --key $op.key @labelArgs --value "@$t" --content-type $op.contentType --yes; Remove-Item $t -Force -ErrorAction SilentlyContinue}
              'kvref'  {az appconfig kv set-keyvault @acArgs --key $op.key @labelArgs --secret-identifier $op.secretId --yes}
            }
          }

  deploy_prod:
    if: ${{ inputs.runProd == 'true' }}
    name: Deploy to PROD
    runs-on: windows-latest
    needs: build_files
    environment: CANADA-PRD   # <-- add Required reviewers in Settings → Environments
    steps:
      - uses: actions/download-artifact@v4
        with:
          name: features-prod
          path: ./artifact
      - name: Push ops to App Config (PROD)
        shell: pwsh
        env:
          APPCONFIG_CONNECTION_STRING: ${{ secrets.APPCONFIG_CONNECTION_STRING }}
        run: |
          $ErrorActionPreference='Stop'
          az config set extension.use_dynamic_install=yes_without_prompt | Out-Null
          $file = Get-ChildItem -LiteralPath ./artifact -Filter *.json | Select-Object -First 1
          if (-not $file) { throw "No ops file found in artifact." }
          $doc = Get-Content -LiteralPath $file.FullName -Raw | ConvertFrom-Json -Depth 200
          $acArgs = @('--connection-string', "${env:APPCONFIG_CONNECTION_STRING}")
          foreach($op in $doc.ops){
            $labelArgs = @(); if ($op.label -and $op.label -ne '_NO_LABEL_') { $labelArgs=@('--label', $op.label) }
            switch($op.type){
              'json'   {$t=New-TemporaryFile;Set-Content -LiteralPath $t -Value $op.value -Encoding utf8 -NoNewline; az appconfig kv set @acArgs --key $op.key @labelArgs --value "@$t" --content-type $op.contentType --yes; Remove-Item $t -Force -ErrorAction SilentlyContinue}
              'string' {$t=New-TemporaryFile;Set-Content -LiteralPath $t -Value $op.value -Encoding utf8 -NoNewline; az appconfig kv set @acArgs --key $op.key @labelArgs --value "@$t" --content-type $op.contentType --yes; Remove-Item $t -Force -ErrorAction SilentlyContinue}
              'kvref'  {az appconfig kv set-keyvault @acArgs --key $op.key @labelArgs --secret-identifier $op.secretId --yes}
            }
          }
