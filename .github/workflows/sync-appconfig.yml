name: Sync Azure App Configuration (build → deploy per stage)

on:
  workflow_dispatch:

permissions:
  contents: read

# Default/fallback names if repo vars aren't set
env:
  DEFAULT_DEV_ENV: dev
  DEFAULT_TST_ENV: CANADA-TST
  DEFAULT_PRD_ENV: CANADA-PRD
  DEFAULT_BU: canada

jobs:
  # ============ DEV: BUILD ============
  build_dev:
    name: Build DEV ops file
    runs-on: windows-latest
    # run under DEV environment to let you scope variables (optional)
    environment: ${{ vars.DEV_ENV && vars.DEV_ENV || env.DEFAULT_DEV_ENV }}
    steps:
      - uses: actions/checkout@v4
      - name: Build DEV
        shell: pwsh
        env:
          BU: ${{ vars.BU && vars.BU || env.DEFAULT_BU }}
        run: |
          $ErrorActionPreference='Stop'
          az config set extension.use_dynamic_install=yes_without_prompt | Out-Null

          # ---------- helpers ----------
          function Read-Json([string]$Path) {
            if (-not (Test-Path -LiteralPath $Path)) { throw "File not found: $Path" }
            $t = Get-Content -LiteralPath $Path -Raw -Encoding utf8
            $t = [regex]::Replace($t,'(?m)^\s*//.*$','')
            $t = [regex]::Replace($t,'(?s)/\*.*?\*/','')
            $t = [regex]::Replace($t,',\s*(\})','$1')
            $t = [regex]::Replace($t,',\s*(\])','$1')
            return $t | ConvertFrom-Json -Depth 100
          }
          function To-HT($o){ if($null -eq $o){return @{}} elseif($o -is [pscustomobject]){$h=@{};$o.PSObject.Properties|%{$h[$_.Name]=To-HT $_.Value};return $h}
            elseif($o -is [System.Collections.IDictionary]){$h=@{};foreach($k in $o.Keys){$h[$k]=To-HT $o[$k]};return $h}
            elseif($o -is [System.Collections.IList]){$a=@();foreach($v in $o){$a+=,(To-HT $v)};return $a} else{return $o} }
          function Resolve-Template($n,$c){
            if ($n -is [string]) {
              $m=[regex]::Match($n,'^\$\{([A-Z0-9_]+)\}$'); if($m.Success){return $c[$m.Groups[1].Value]}
              return [regex]::Replace($n,'\$\{([A-Z0-9_]+)\}',{ param($m) [string]$c[$m.Groups[1].Value] })
            } elseif ($n -is [pscustomobject] -or $n -is [System.Collections.IDictionary]) {
              $h=@{}; $names = if($n -is [pscustomobject]){$n.PSObject.Properties.Name}else{$n.Keys}
              foreach($k in $names){ $h[$k] = Resolve-Template $n.$k $c }; return $h
            } elseif ($n -is [System.Collections.IList]) {
              $arr=@(); foreach($v in $n){ $arr += ,(Resolve-Template $v $c) }; return $arr
            } else { return $n }
          }

          # ---------- paths ----------
          $repo = $env:GITHUB_WORKSPACE
          $bu   = $env:BU
          $featuresPath = Join-Path $repo ("config/{0}/files/features.json" -f $bu)
          $varsPath     = Join-Path $repo ("config/{0}/files/variables.dev.json" -f $bu)
          $deployDir    = Join-Path $repo ("config/{0}/deployments" -f $bu)
          New-Item -ItemType Directory -Force -Path $deployDir | Out-Null
          $outPath      = Join-Path $deployDir ("features-dev.{0}.ops.json" -f $env:GITHUB_RUN_ID)

          # ---------- load ----------
          $features = Read-Json $featuresPath
          $varsObj  = Read-Json $varsPath
          $ctx      = To-HT $varsObj
          $defaultLabel = $ctx['TARGET_LABEL']

          # ---------- render → ops ----------
          $ops = @()
          foreach($f in $features.features){
            $key  = $f.key
            $type = if($f.type){$f.type}else{'json'}

            # per-feature label override
            $featureLabel = $defaultLabel
            if ($f | Get-Member -Name label -MemberType NoteProperty) {
              $raw = $f.label
              $featureLabel = ($raw -is [string]) ? (Resolve-Template $raw $ctx) : $raw
            }

            switch ($type) {
              'json' {
                $rendered = Resolve-Template $f.template $ctx
                $jsonVal  = $rendered | ConvertTo-Json -Depth 100 -Compress
                $ops += [pscustomobject]@{
                  type='json'; key=$key; label=$featureLabel; contentType='application/json'; value=$jsonVal
                }
              }
              'string' {
                $rendered = Resolve-Template $f.value $ctx
                $str = ($rendered -is [string]) ? $rendered : ($rendered | ConvertTo-Json -Depth 8 -Compress)
                $ops += [pscustomobject]@{
                  type='string'; key=$key; label=$featureLabel; contentType='text/plain'; value=$str
                }
              }
              'kvref' {
                $varName = $f.secretVar
                $val     = $ctx[$varName]
                if (-not $val) { Write-Host ("Skip {0}: {1} not set" -f $key,$varName); continue }
                $kvName  = $ctx['KEYVAULT_NAME']
                $secretId = ($val -like 'https://*') ? $val : ("https://{0}.vault.azure.net/secrets/{1}" -f $kvName,$val)
                $ops += [pscustomobject]@{
                  type='kvref'; key=$key; label=$featureLabel; secretId=$secretId
                }
              }
            }
          }

          # ---------- write manifest ----------
          $manifest = [pscustomobject]@{
            generatedAt = (Get-Date).ToUniversalTime().ToString('s')+'Z'
            environment = 'dev'
            bu          = $bu
            defaultLabel= $defaultLabel
            ops         = $ops
          } | ConvertTo-Json -Depth 100

          Set-Content -LiteralPath $outPath -Value $manifest -Encoding utf8 -NoNewline
          Write-Host "Built DEV ops -> $outPath"

      - name: Upload DEV artifact
        uses: actions/upload-artifact@v4
        with:
          name: features-dev
          path: config/${{ vars.BU && vars.BU || env.DEFAULT_BU }}/deployments/features-dev.${{ github.run_id }}.ops.json

  # ============ DEV: DEPLOY ============
  deploy_dev:
    name: Deploy DEV
    runs-on: windows-latest
    needs: build_dev
    environment: ${{ vars.DEV_ENV && vars.DEV_ENV || env.DEFAULT_DEV_ENV }}
    steps:
      - uses: actions/download-artifact@v4
        with:
          name: features-dev
          path: ./artifact
      - name: Push to App Config (DEV)
        shell: pwsh
        env:
          APPCONFIG_CONNECTION_STRING: ${{ secrets.APPCONFIG_CONNECTION_STRING }}
        run: |
          $ErrorActionPreference='Stop'
          az config set extension.use_dynamic_install=yes_without_prompt | Out-Null
          $file = Get-ChildItem -Path ./artifact -Filter *.json | Select-Object -First 1
          if (-not $file) { throw "No ops file in artifact." }
          $doc = Get-Content -LiteralPath $file.FullName -Raw | ConvertFrom-Json -Depth 100
          $acArgs = @('--connection-string', "${env:APPCONFIG_CONNECTION_STRING}")
          foreach($op in $doc.ops){
            $labelArgs = @(); if ($op.label -and $op.label -ne '_NO_LABEL_') { $labelArgs=@('--label',$op.label) }
            switch($op.type){
              'json'   { $t=New-TemporaryFile; Set-Content -LiteralPath $t -Value $op.value -Encoding utf8 -NoNewline; az appconfig kv set @acArgs --key $op.key @labelArgs --value "@$t" --content-type $op.contentType --yes; Remove-Item $t -Force -ErrorAction SilentlyContinue }
              'string' { $t=New-TemporaryFile; Set-Content -LiteralPath $t -Value $op.value -Encoding utf8 -NoNewline; az appconfig kv set @acArgs --key $op.key @labelArgs --value "@$t" --content-type $op.contentType --yes; Remove-Item $t -Force -ErrorAction SilentlyContinue }
              'kvref'  { az appconfig kv set-keyvault @acArgs --key $op.key @labelArgs --secret-identifier $op.secretId --yes }
            }
          }

  # ============ TEST: BUILD ============
  build_tst:
    name: Build TST ops file
    runs-on: windows-latest
    needs: deploy_dev
    environment: ${{ vars.TST_ENV && vars.TST_ENV || env.DEFAULT_TST_ENV }}
    steps:
      - uses: actions/checkout@v4
      - name: Build TST
        shell: pwsh
        env:
          BU: ${{ vars.BU && vars.BU || env.DEFAULT_BU }}
        run: |
          $ErrorActionPreference='Stop'
          az config set extension.use_dynamic_install=yes_without_prompt | Out-Null
          # same script body as DEV build, but:
          $repo = $env:GITHUB_WORKSPACE; $bu=$env:BU
          $featuresPath = Join-Path $repo ("config/{0}/files/features.json" -f $bu)
          $varsPath     = Join-Path $repo ("config/{0}/files/variables.test.json" -f $bu)
          $deployDir    = Join-Path $repo ("config/{0}/deployments" -f $bu)
          New-Item -ItemType Directory -Force -Path $deployDir | Out-Null
          $outPath      = Join-Path $deployDir ("features-test.{0}.ops.json" -f $env:GITHUB_RUN_ID)

          function Read-Json([string]$Path){ if(-not(Test-Path $Path)){throw "File not found: $Path"}; $t=Get-Content $Path -Raw -Encoding utf8; $t=[regex]::Replace($t,'(?m)^\s*//.*$','');$t=[regex]::Replace($t,'(?s)/\*.*?\*/','');$t=[regex]::Replace($t,',\s*(\})','$1');$t=[regex]::Replace($t,',\s*(\])','$1'); $t|ConvertFrom-Json -Depth 100 }
          function To-HT($o){ if($null -eq $o){return @{}} elseif($o -is [pscustomobject]){$h=@{};$o.PSObject.Properties|%{$h[$_.Name]=To-HT $_.Value};return $h}elseif($o -is [System.Collections.IDictionary]){$h=@{};foreach($k in $o.Keys){$h[$k]=To-HT $o[$k]};return $h}elseif($o -is [System.Collections.IList]){$a=@();foreach($v in $o){$a+=,(To-HT $v)};return $a}else{return $o}}
          function Resolve-Template($n,$c){ if($n -is [string]){$m=[regex]::Match($n,'^\$\{([A-Z0-9_]+)\}$');if($m.Success){return $c[$m.Groups[1].Value]} return [regex]::Replace($n,'\$\{([A-Z0-9_]+)\}',{param($m)[string]$c[$m.Groups[1].Value]}) } elseif ($n -is [pscustomobject] -or $n -is [System.Collections.IDictionary]){$h=@{};$names=if($n -is [pscustomobject]){$n.PSObject.Properties.Name}else{$n.Keys};foreach($k in $names){$h[$k]=Resolve-Template $n.$k $c};return $h} elseif($n -is [System.Collections.IList]){$arr=@();foreach($v in $n){$arr+=,(Resolve-Template $v $c)};return $arr}else{return $n}}
          $features=Read-Json $featuresPath; $varsObj=Read-Json $varsPath; $ctx=To-HT $varsObj; $defaultLabel=$ctx['TARGET_LABEL']
          $ops=@()
          foreach($f in $features.features){
            $key=$f.key; $type=if($f.type){$f.type}else{'json'}
            $featureLabel=$defaultLabel; if($f|Get-Member -Name label -MemberType NoteProperty){$raw=$f.label; $featureLabel=($raw -is [string])?(Resolve-Template $raw $ctx):$raw}
            switch($type){
              'json'   {$rendered=Resolve-Template $f.template $ctx; $jsonVal=$rendered|ConvertTo-Json -Depth 100 -Compress; $ops+=@{type='json';key=$key;label=$featureLabel;contentType='application/json';value=$jsonVal}}
              'string' {$rendered=Resolve-Template $f.value $ctx; $str=($rendered -is [string])?$rendered:($rendered|ConvertTo-Json -Depth 8 -Compress); $ops+=@{type='string';key=$key;label=$featureLabel;contentType='text/plain';value=$str}}
              'kvref'  {$varName=$f.secretVar;$val=$ctx[$varName]; if(-not $val){Write-Host ("Skip {0}: {1} not set" -f $key,$varName); continue}; $secretId=($val -like 'https://*')?$val:("https://{0}.vault.azure.net/secrets/{1}" -f $ctx['KEYVAULT_NAME'],$val); $ops+=@{type='kvref';key=$key;label=$featureLabel;secretId=$secretId}}
            }
          }
          $manifest=[pscustomobject]@{generatedAt=(Get-Date).ToUniversalTime().ToString('s')+'Z';environment='test';bu=$bu;defaultLabel=$defaultLabel;ops=$ops}|ConvertTo-Json -Depth 100
          Set-Content -LiteralPath $outPath -Value $manifest -Encoding utf8 -NoNewline
          Write-Host "Built TEST ops -> $outPath"

      - uses: actions/upload-artifact@v4
        with:
          name: features-test
          path: config/${{ vars.BU && vars.BU || env.DEFAULT_BU }}/deployments/features-test.${{ github.run_id }}.ops.json

  # ============ TEST: DEPLOY (with approvals via environment) ============
  deploy_tst:
    name: Deploy TST
    runs-on: windows-latest
    needs: build_tst
    environment: ${{ vars.TST_ENV && vars.TST_ENV || env.DEFAULT_TST_ENV }}
    steps:
      - uses: actions/download-artifact@v4
        with:
          name: features-test
          path: ./artifact
      - name: Push to App Config (TST)
        shell: pwsh
        env:
          APPCONFIG_CONNECTION_STRING: ${{ secrets.APPCONFIG_CONNECTION_STRING }}
        run: |
          $ErrorActionPreference='Stop'
          az config set extension.use_dynamic_install=yes_without_prompt | Out-Null
          $file = Get-ChildItem -Path ./artifact -Filter *.json | Select-Object -First 1
          if (-not $file) { throw "No ops file in artifact." }
          $doc = Get-Content -LiteralPath $file.FullName -Raw | ConvertFrom-Json -Depth 100
          $acArgs = @('--connection-string', "${env:APPCONFIG_CONNECTION_STRING}")
          foreach($op in $doc.ops){
            $labelArgs = @(); if ($op.label -and $op.label -ne '_NO_LABEL_') { $labelArgs=@('--label',$op.label) }
            switch($op.type){
              'json'   {$t=New-TemporaryFile; Set-Content -LiteralPath $t -Value $op.value -Encoding utf8 -NoNewline; az appconfig kv set @acArgs --key $op.key @labelArgs --value "@$t" --content-type $op.contentType --yes; Remove-Item $t -Force -ErrorAction SilentlyContinue}
              'string' {$t=New-TemporaryFile; Set-Content -LiteralPath $t -Value $op.value -Encoding utf8 -NoNewline; az appconfig kv set @acArgs --key $op.key @labelArgs --value "@$t" --content-type $op.contentType --yes; Remove-Item $t -Force -ErrorAction SilentlyContinue}
              'kvref'  {az appconfig kv set-keyvault @acArgs --key $op.key @labelArgs --secret-identifier $op.secretId --yes}
            }
          }

  # ============ PROD: BUILD ============
  build_prd:
    name: Build PRD ops file
    runs-on: windows-latest
    needs: deploy_tst
    environment: ${{ vars.PRD_ENV && vars.PRD_ENV || env.DEFAULT_PRD_ENV }}
    steps:
      - uses: actions/checkout@v4
      - name: Build PRD
        shell: pwsh
        env:
          BU: ${{ vars.BU && vars.BU || env.DEFAULT_BU }}
        run: |
          $ErrorActionPreference='Stop'
          az config set extension.use_dynamic_install=yes_without_prompt | Out-Null
          $repo=$env:GITHUB_WORKSPACE; $bu=$env:BU
          $featuresPath = Join-Path $repo ("config/{0}/files/features.json" -f $bu)
          $varsPath     = Join-Path $repo ("config/{0}/files/variables.prod.json" -f $bu)
          $deployDir    = Join-Path $repo ("config/{0}/deployments" -f $bu)
          New-Item -ItemType Directory -Force -Path $deployDir | Out-Null
          $outPath      = Join-Path $deployDir ("features-prod.{0}.ops.json" -f $env:GITHUB_RUN_ID)

          function Read-Json([string]$Path){ if(-not(Test-Path $Path)){throw "File not found: $Path"}; $t=Get-Content $Path -Raw -Encoding utf8; $t=[regex]::Replace($t,'(?m)^\s*//.*$','');$t=[regex]::Replace($t,'(?s)/\*.*?\*/','');$t=[regex]::Replace($t,',\s*(\})','$1');$t=[regex]::Replace($t,',\s*(\])','$1'); $t|ConvertFrom-Json -Depth 100 }
          function To-HT($o){ if($null -eq $o){return @{}} elseif($o -is [pscustomobject]){$h=@{};$o.PSObject.Properties|%{$h[$_.Name]=To-HT $_.Value};return $h}elseif($o -is [System.Collections.IDictionary]){$h=@{};foreach($k in $o.Keys){$h[$k]=To-HT $o[$k]};return $h}elseif($o -is [System.Collections.IList]){$a=@();foreach($v in $o){$a+=,(To-HT $v)};return $a}else{return $o}}
          function Resolve-Template($n,$c){ if($n -is [string]){$m=[regex]::Match($n,'^\$\{([A-Z0-9_]+)\}$');if($m.Success){return $c[$m.Groups[1].Value]} return [regex]::Replace($n,'\$\{([A-Z0-9_]+)\}',{param($m)[string]$c[$m.Groups[1].Value]}) } elseif ($n -is [pscustomobject] -or $n -is [System.Collections.IDictionary]){$h=@{};$names=if($n -is [pscustomobject]){$n.PSObject.Properties.Name}else{$n.Keys};foreach($k in $names){$h[$k]=Resolve-Template $n.$k $c};return $h} elseif($n -is [System.Collections.IList]){$arr=@();foreach($v in $n){$arr+=,(Resolve-Template $v $c)};return $arr}else{return $n}}
          $features=Read-Json $featuresPath; $varsObj=Read-Json $varsPath; $ctx=To-HT $varsObj; $defaultLabel=$ctx['TARGET_LABEL']
          $ops=@()
          foreach($f in $features.features){
            $key=$f.key; $type=if($f.type){$f.type}else{'json'}
            $featureLabel=$defaultLabel; if($f|Get-Member -Name label -MemberType NoteProperty){$raw=$f.label; $featureLabel=($raw -is [string])?(Resolve-Template $raw $ctx):$raw}
            switch($type){
              'json'   {$rendered=Resolve-Template $f.template $ctx; $jsonVal=$rendered|ConvertTo-Json -Depth 100 -Compress; $ops+=@{type='json';key=$key;label=$featureLabel;contentType='application/json';value=$jsonVal}}
              'string' {$rendered=Resolve-Template $f.value $ctx; $str=($rendered -is [string])?$rendered:($rendered|ConvertTo-Json -Depth 8 -Compress); $ops+=@{type='string';key=$key;label=$featureLabel;contentType='text/plain';value=$str}}
              'kvref'  {$varName=$f.secretVar;$val=$ctx[$varName]; if(-not $val){Write-Host ("Skip {0}: {1} not set" -f $key,$varName); continue}; $secretId=($val -like 'https://*')?$val:("https://{0}.vault.azure.net/secrets/{1}" -f $ctx['KEYVAULT_NAME'],$val); $ops+=@{type='kvref';key=$key;label=$featureLabel;secretId=$secretId}}
            }
          }
          $manifest=[pscustomobject]@{generatedAt=(Get-Date).ToUniversalTime().ToString('s')+'Z';environment='prod';bu=$bu;defaultLabel=$defaultLabel;ops=$ops}|ConvertTo-Json -Depth 100
          Set-Content -LiteralPath $outPath -Value $manifest -Encoding utf8 -NoNewline
          Write-Host "Built PROD ops -> $outPath"

      - uses: actions/upload-artifact@v4
        with:
          name: features-prod
          path: config/${{ vars.BU && vars.BU || env.DEFAULT_BU }}/deployments/features-prod.${{ github.run_id }}.ops.json

  # ============ PROD: DEPLOY (with approvals via environment) ============
  deploy_prd:
    name: Deploy PRD
    runs-on: windows-latest
    needs: build_prd
    environment: ${{ vars.PRD_ENV && vars.PRD_ENV || env.DEFAULT_PRD_ENV }}
    steps:
      - uses: actions/download-artifact@v4
        with:
          name: features-prod
          path: ./artifact
      - name: Push to App Config (PRD)
        shell: pwsh
        env:
          APPCONFIG_CONNECTION_STRING: ${{ secrets.APPCONFIG_CONNECTION_STRING }}
        run: |
          $ErrorActionPreference='Stop'
          az config set extension.use_dynamic_install=yes_without_prompt | Out-Null
          $file = Get-ChildItem -Path ./artifact -Filter *.json | Select-Object -First 1
          if (-not $file) { throw "No ops file in artifact." }
          $doc = Get-Content -LiteralPath $file.FullName -Raw | ConvertFrom-Json -Depth 100
          $acArgs = @('--connection-string', "${env:APPCONFIG_CONNECTION_STRING}")
          foreach($op in $doc.ops){
            $labelArgs = @(); if ($op.label -and $op.label -ne '_NO_LABEL_') { $labelArgs=@('--label',$op.label) }
            switch($op.type){
              'json'  {$t=New-TemporaryFile; Set-Content -LiteralPath $t -Value $op.value -Encoding utf8 -NoNewline; az appconfig kv set @acArgs --key $op.key @labelArgs --value "@$t" --content-type $op.contentType --yes; Remove-Item $t -Force -ErrorAction SilentlyContinue}
              'string' {$t=New-TemporaryFile; Set-Content -LiteralPath $t -Value $op.value -Encoding utf8 -NoNewline; az appconfig kv set @acArgs --key $op.key @labelArgs --value "@$t" --content-type $op.contentType --yes; Remove-Item $t -Force -ErrorAction SilentlyContinue}
              'kvref'  {az appconfig kv set-keyvault @acArgs --key $op.key @labelArgs --secret-identifier $op.secretId --yes}
            }
          }
