name: Sync Azure App Configuration (build → deploy, single env)

on:
  workflow_dispatch:
    inputs:
      businessUnit:
        description: "BU folder under config/ (e.g. CANADA)"
        required: true
        default: "CANADA"
      targetEnv:
        description: "Target environment"
        type: choice
        options: [dev, tst, prd]
        required: true
        default: dev
      appConfigConnectionString:
        description: "Azure App Configuration connection string"
        required: true
        default: ""  # NOTE: Inputs are visible to run viewers. Use secrets if needed.
      featuresFile:
        description: "Features JSON (under config/<BU>/)"
        required: true
        default: "features.json"
      variablesFile:
        description: "Variables JSON (under config/<BU>/). Leave blank to use variables.<env>.json"
        required: false
        default: ""

permissions:
  contents: read

jobs:
  # ============================= BUILD =============================
  build:
    name: Build manifest
    runs-on: windows-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Build ops (render features → manifest)
        shell: pwsh
        env:
          BU:            ${{ inputs.businessUnit }}
          TARGET_ENV:    ${{ inputs.targetEnv }}
          FEATURES_FILE: ${{ inputs.featuresFile }}
          VARS_FILE_IN:  ${{ inputs.variablesFile }}
        run: |
          $ErrorActionPreference='Stop'
          az config set extension.use_dynamic_install=yes_without_prompt | Out-Null

          # --- helpers (comment-tolerant JSON, normalize to HT, recursive templating) ---
          function Read-Json([string]$Path) {
            if (-not (Test-Path -LiteralPath $Path)) { throw "File not found: $Path" }
            $t = Get-Content -LiteralPath $Path -Raw -Encoding utf8
            $t = [regex]::Replace($t,'(?m)^\s*//.*$','')  # // comments
            $t = [regex]::Replace($t,'(?s)/\*.*?\*/','')  # /* */ comments
            $t = [regex]::Replace($t,',\s*(\})','$1')     # trailing commas }
            $t = [regex]::Replace($t,',\s*(\])','$1')     # trailing commas ]
            return $t | ConvertFrom-Json -Depth 100
          }
          function To-HT($o){
            if($null -eq $o){return @{}}
            elseif($o -is [pscustomobject]){ $h=@{}; $o.PSObject.Properties|%{$h[$_.Name]=To-HT $_.Value}; return $h }
            elseif($o -is [System.Collections.IDictionary]){ $h=@{}; foreach($k in $o.Keys){$h[$k]=To-HT $o[$k]}; return $h }
            elseif($o -is [System.Collections.IList]){ $a=@(); foreach($v in $o){$a+=,(To-HT $v)}; return $a }
            else{ return $o }
          }
          function Resolve-Template($n,$c){
            if ($n -is [string]) {
              $m=[regex]::Match($n,'^\$\{([A-Z0-9_]+)\}$'); if($m.Success){return $c[$m.Groups[1].Value]}
              return [regex]::Replace($n,'\$\{([A-Z0-9_]+)\}',{ param($m) [string]$c[$m.Groups[1].Value] })
            } elseif ($n -is [pscustomobject] -or $n -is [System.Collections.IDictionary]) {
              $h=@{}; $names = if($n -is [pscustomobject]){$n.PSObject.Properties.Name}else{$n.Keys}
              foreach($k in $names){ $h[$k] = Resolve-Template $n.$k $c }; return $h
            } elseif ($n -is [System.Collections.IList]) {
              $arr=@(); foreach($v in $n){ $arr += ,(Resolve-Template $v $c) }; return $arr
            } else { return $n }
          }

          # --- inputs & paths ---
          $repo = $env:GITHUB_WORKSPACE
          $bu   = $env:BU
          $envName = $env:TARGET_ENV  # dev|tst|prd

          if ([string]::IsNullOrWhiteSpace($env:VARS_FILE_IN)) {
            $map = @{ dev='variables.dev.json'; tst='variables.tst.json'; prd='variables.prd.json' }
            $varsFile = $map[$envName]
          } else {
            $varsFile = $env:VARS_FILE_IN
          }

          $featuresPath = Join-Path $repo ("config/{0}/{1}" -f $bu, $env:FEATURES_FILE)
          $varsPath     = Join-Path $repo ("config/{0}/{1}" -f $bu, $varsFile)
          $buildDir     = Join-Path $repo ("config/{0}/builds" -f $bu)
          New-Item -ItemType Directory -Force -Path $buildDir | Out-Null

          $suffix = switch ($envName) { 'dev' {'dev'} 'tst' {'test'} 'prd' {'prod'} default {$envName} }
          $outPath = Join-Path $buildDir ("features-{0}.{1}.ops.json" -f $suffix,$env:GITHUB_RUN_ID)

          # --- load & render ---
          $features = Read-Json $featuresPath
          $varsObj  = Read-Json $varsPath
          $ctx      = To-HT $varsObj

          $ops = @()
          foreach($f in $features.features){
            $key  = $f.key
            $type = if($f.type){$f.type}else{'json'}

            # Label ONLY from features.json (missing/empty/_NO_LABEL_ => no label)
            $featureLabel = $null
            if ($f | Get-Member -Name label -MemberType NoteProperty) {
              $raw = $f.label
              $featureLabel = ($raw -is [string]) ? (Resolve-Template $raw $ctx) : $raw
              if ([string]::IsNullOrWhiteSpace($featureLabel) -or $featureLabel -eq '_NO_LABEL_') { $featureLabel = $null }
            }

            switch ($type) {
              'json' {
                $rendered = Resolve-Template $f.template $ctx
                $jsonVal  = $rendered | ConvertTo-Json -Depth 100 -Compress
                $ops += [pscustomobject]@{
                  type='json'; key=$key; label=$featureLabel; contentType='application/json'; value=$jsonVal
                }
              }
              'string' {
                $rendered = Resolve-Template $f.value $ctx
                $str = ($rendered -is [string]) ? $rendered : ($rendered | ConvertTo-Json -Depth 8 -Compress)
                $ops += [pscustomobject]@{
                  type='string'; key=$key; label=$featureLabel; contentType='text/plain'; value=$str
                }
              }
              'kvref' {
                $varName = $f.secretVar
                $val     = $ctx[$varName]
                if (-not $val) { Write-Host ("Skip {0}: {1} not set" -f $key,$varName); continue }
                $kvName  = $ctx['KEYVAULT_NAME']
                $secretId = ($val -like 'https://*') ? $val : ("https://{0}.vault.azure.net/secrets/{1}" -f $kvName,$val)
                $ops += [pscustomobject]@{
                  type='kvref'; key=$key; label=$featureLabel; secretId=$secretId
                }
              }
            }
          }

          $manifest = [pscustomobject]@{
            generatedAt = (Get-Date).ToUniversalTime().ToString('s')+'Z'
            environment = $envName
            bu          = $bu
            ops         = $ops
          } | ConvertTo-Json -Depth 100

          Set-Content -LiteralPath $outPath -Value $manifest -Encoding utf8 -NoNewline
          Write-Host "Built $envName ops -> $outPath"

      - name: Upload manifest artifact
        uses: actions/upload-artifact@v4
        with:
          name: features-${{ inputs.targetEnv }}
          path: config/${{ inputs.businessUnit }}/builds/features-${{ inputs.targetEnv == 'tst' && 'test' || (inputs.targetEnv == 'prd' && 'prod' || inputs.targetEnv) }}.${{ github.run_id }}.ops.json

  # ============================= DEPLOY =============================
  deploy:
    name: Deploy manifest to App Config
    runs-on: windows-latest
    needs: [build]
    steps:
      - name: Download manifest artifact
        uses: actions/download-artifact@v4
        with:
          name: features-${{ inputs.targetEnv }}
          path: ./artifact

      - name: Deploy to Azure App Configuration
        shell: pwsh
        env:
          APPCONFIG_CS: ${{ inputs.appConfigConnectionString }}
        run: |
          $ErrorActionPreference='Stop'
          az config set extension.use_dynamic_install=yes_without_prompt | Out-Null

          $file = Get-ChildItem -Path ./artifact -Filter *.json | Select-Object -First 1
          if (-not $file) { throw "No ops file in artifact." }

          if ([string]::IsNullOrWhiteSpace($env:APPCONFIG_CS)) { throw "AppConfig connection string input is empty." }
          $acArgs = @('--connection-string', $env:APPCONFIG_CS)

          $doc = Get-Content -LiteralPath $file.FullName -Raw | ConvertFrom-Json -Depth 100
          foreach($op in $doc.ops){
            $labelArgs = @(); if ($op.label) { $labelArgs = @('--label', $op.label) }
            switch($op.type){
              'json' {
                $t=New-TemporaryFile
                Set-Content -LiteralPath $t -Value $op.value -Encoding utf8 -NoNewline
                az appconfig kv set @acArgs --key $op.key @labelArgs --value "@$t" --content-type $op.contentType --yes
                Remove-Item $t -Force -ErrorAction SilentlyContinue
              }
              'string' {
                $t=New-TemporaryFile
                Set-Content -LiteralPath $t -Value $op.value -Encoding utf8 -NoNewline
                az appconfig kv set @acArgs --key $op.key @labelArgs --value "@$t" --content-type $op.contentType --yes
                Remove-Item $t -Force -ErrorAction SilentlyContinue
              }
              'kvref' {
                az appconfig kv set-keyvault @acArgs --key $op.key @labelArgs --secret-identifier $op.secretId --yes
              }
            }
          }
