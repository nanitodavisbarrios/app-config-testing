name: Sync Azure App Configuration

on:
  workflow_dispatch:
    inputs:
      runDev:
        description: "Run DEV stage?"
        required: true
        default: "true"
      runTest:
        description: "Run TEST stage?"
        required: true
        default: "false"
      runProd:
        description: "Run PROD stage?"
        required: true
        default: "false"

permissions:
  contents: read

# ---------------- DEV ----------------
jobs:
  sync_dev:
    if: ${{ inputs.runDev == 'true' }}
    name: Sync to DEV
    runs-on: windows-latest
    environment: dev
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Render & push features (DEV via connection string)
        shell: pwsh
        env:
            # Required secret (per environment)
            APPCONFIG_CONNECTION_STRING: ${{ secrets.APPCONFIG_CONNECTION_STRING }}
            # Optional label (per environment): use _NO_LABEL_ or leave empty for (No label)
            TARGET_LABEL: ${{ vars.TARGET_LABEL }}

            # Paths in your repo
            FEATURES_PATH: config/features.json
            VARS_PATH:     config/variables.dev.json

            # Optional: any variables/secrets referenced by features.json (override .json values)
            FUNCLOC_CLIENT_SECRET_URI: sdfasdfasdfasfdsdfsdfasdfrth #{{ secrets.FUNCLOC_CLIENT_SECRET_URI }}
            FUNCLOC_OCPAPIM_SUBSCRIPTION_KEY_URI: adfasdfhrykjryiulmtgumjrtuktrk #{{ secrets.FUNCLOC_OCPAPIM_SUBSCRIPTION_KEY_URI }}
        run: |
          $ErrorActionPreference = 'Stop'
          az config set extension.use_dynamic_install=yes_without_prompt | Out-Null

          # --- helpers: tolerant JSON loader (allows //, /* */, trailing commas) ---
          function Read-JsonStrictish([string]$Path) {
            $full = Join-Path $env:GITHUB_WORKSPACE $Path
            if (-not (Test-Path -LiteralPath $full)) { throw "File not found: $full" }
            $text = Get-Content -LiteralPath $full -Raw -Encoding utf8
            $text = [regex]::Replace($text, '(?m)^\s*//.*$', '')      # strip // comments
            $text = [regex]::Replace($text, '(?s)/\*.*?\*/', '')      # strip /* */ comments
            $text = [regex]::Replace($text, ',\s*(\})', '$1')         # strip trailing commas
            $text = [regex]::Replace($text, ',\s*(\])', '$1')
            return $text | ConvertFrom-Json -Depth 100
          }
          function To-Hashtable($obj) {
            if ($null -eq $obj) { return $null }
            if ($obj -is [pscustomobject]) {
              $h=@{}; foreach ($p in $obj.PSObject.Properties) { $h[$p.Name] = To-Hashtable $p.Value }; return $h
            } elseif ($obj -is [System.Collections.IDictionary]) {
              $h=@{}; foreach ($k in $obj.Keys) { $h[$k] = To-Hashtable $obj[$k] }; return $h
            } elseif ($obj -is [System.Collections.IList]) {
              $a=@(); foreach ($v in $obj) { $a += ,(To-Hashtable $v) }; return $a
            } else { return $obj }
          }
          function Resolve-Template($node, $ctx) {
            if ($node -is [string]) {
              # whole string = ${VAR} -> preserve type (ctx[VAR] value)
              $m = [regex]::Match($node, '^\$\{([A-Z0-9_]+)\}$')
              if ($m.Success) { return $ctx[$m.Groups[1].Value] }
              # partial string -> replace with stringified value
              return [regex]::Replace($node, '\$\{([A-Z0-9_]+)\}', { param($m) [string]$ctx[$m.Groups[1].Value] })
            } elseif ($node -is [pscustomobject] -or $node -is [System.Collections.IDictionary]) {
              $h=@{}; $names = if ($node -is [pscustomobject]) { $node.PSObject.Properties.Name } else { $node.Keys }
              foreach ($k in $names) { $h[$k] = Resolve-Template $node.$k $ctx }; return $h
            } elseif ($node -is [System.Collections.IList]) {
              $arr=@(); foreach ($v in $node) { $arr += ,(Resolve-Template $v $ctx) }; return $arr
            } else { return $node }
          }

          # --- load features & variables, build context ---
          $features = Read-JsonStrictish $env:FEATURES_PATH
          $varsObj  = Read-JsonStrictish $env:VARS_PATH
          $ctx      = To-Hashtable $varsObj

          # overlay env overrides (GitHub env/secret > file)
          Get-ChildItem Env: | ForEach-Object {
            $k=$_.Name; $v=$_.Value
            if ($ctx.ContainsKey($k) -and ($ctx[$k] -is [bool])) {
              $ctx[$k] = ($v -match '^(?i:true|1)$')
            } else {
              $ctx[$k] = $v
            }
          }

          # derive UNC_BASE if missing
          if (-not $ctx.ContainsKey('UNC_BASE')) {
            $acct  = $ctx['STORAGE_ACCOUNT']
            $share = if ($ctx['SHARE_USERCONTENT']) { $ctx['SHARE_USERCONTENT'] } else { 'usercontent' }
            $ctx['UNC_BASE'] = $(if ($acct) { "\\$acct.file.core.windows.net\$share" } else { "\\.invalid\$share" })
          }

          # label args (omit when _NO_LABEL_ or empty)
          $label = $ctx['TARGET_LABEL']; $labelArgs=@()
          if ($label -and $label -ne '_NO_LABEL_') { $labelArgs = @('--label', $label) }

          # App Config args (connection string only; no azure/login required)
          $cs = $env:APPCONFIG_CONNECTION_STRING
          if (-not $cs) { throw "APPCONFIG_CONNECTION_STRING not set in this environment." }
          $acArgs = @('--connection-string', $cs)

          # --- push all features ---
          foreach ($f in $features.features) {
            $key  = $f.key
            $type = if ($f.type) { $f.type } else { 'json' }

            switch ($type) {
              'json' {
                $rendered = Resolve-Template $f.template $ctx
                $jsonVal  = $rendered | ConvertTo-Json -Depth 64 -Compress
                Write-Host "Upserting JSON $key (label=$label)"
                az appconfig kv set @acArgs --key $key @labelArgs --value $jsonVal --content-type 'application/json' --yes
              }
              'string' {
                $rendered = Resolve-Template $f.value $ctx
                $str = if ($rendered -is [string]) { $rendered } else { ($rendered | ConvertTo-Json -Compress -Depth 8) }
                Write-Host "Upserting STRING $key (label=$label)"
                az appconfig kv set @acArgs --key $key @labelArgs --value $str --content-type 'text/plain' --yes
              }
              'kvref' {
                $varName  = $f.secretVar
                $secretId = $ctx[$varName]
                if (-not $secretId) { Write-Host "Skipping ${key:} ${varName} not set"; break }
                Write-Host "Upserting KVREF $key (label=$label) from $varName"
                az appconfig kv set-keyvault @acArgs --key $key @labelArgs --secret-identifier $secretId --yes
              }
              default {
                Write-Host "Unknown type '$type' for $key; skipping."
              }
            }
          }

          # summary
          az appconfig kv list @acArgs @labelArgs --key "Feature:*" `
            --query "[].{key:key,label:label,contentType:content_type,lastModified:last_modified}" -o table

  # ---------------- TEST ----------------
  sync_test:
    if: ${{ inputs.runTest == 'true' }}
    name: Sync to TEST
    runs-on: windows-latest
    environment: CANADA-TST
    needs: [sync_dev]
    steps:
      - uses: actions/checkout@v4
      - name: Render & push features (TEST via connection string)
        shell: pwsh
        env:
          APPCONFIG_CONNECTION_STRING: ${{ secrets.APPCONFIG_CONNECTION_STRING }}
          TARGET_LABEL: ${{ vars.TARGET_LABEL }}
          FEATURES_PATH: config/features.json
          VARS_PATH:     config/variables.test.json
          FUNCLOC_CLIENT_SECRET_URI: sdfasdfasdfasfdsdfsdfasdfrth #{{ secrets.FUNCLOC_CLIENT_SECRET_URI }}
          FUNCLOC_OCPAPIM_SUBSCRIPTION_KEY_URI: adfasdfhrykjryiulmtgumjrtuktrk #{{ secrets.FUNCLOC_OCPAPIM_SUBSCRIPTION_KEY_URI }}
        run: |
          # copy the entire pwsh block from DEV step above and only change VARS_PATH to variables.test.json

  # ---------------- PROD ----------------
  sync_prod:
    if: ${{ inputs.runProd == 'true' }}
    name: Sync to PROD
    runs-on: windows-latest
    environment: CANADA-PRD
    needs: [sync_test]
    steps:
      - uses: actions/checkout@v4
      - name: Render & push features (PROD via connection string)
        shell: pwsh
        env:
          APPCONFIG_CONNECTION_STRING: ${{ secrets.APPCONFIG_CONNECTION_STRING }}
          TARGET_LABEL: ${{ vars.TARGET_LABEL }}
          FEATURES_PATH: config/features.json
          VARS_PATH:     config/variables.prod.json
          FUNCLOC_CLIENT_SECRET_URI: sdfasdfasdfasfdsdfsdfasdfrth #{{ secrets.FUNCLOC_CLIENT_SECRET_URI }}
          FUNCLOC_OCPAPIM_SUBSCRIPTION_KEY_URI: adfasdfhrykjryiulmtgumjrtuktrk #{{ secrets.FUNCLOC_OCPAPIM_SUBSCRIPTION_KEY_URI }}
        run: |
          # copy the entire pwsh block from DEV step above and only change VARS_PATH to variables.prod.json